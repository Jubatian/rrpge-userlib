/**
**  \file      RRPGE User Library math component, 32 bit reciprocal test
**  \brief     The main program file
**  \author    Sandor Zsuga (Jubatian)
**  \copyright 2013 - 2014, GNU GPLv3 (version 3 of the GNU General Public
**             License) extended as RRPGEvt (temporary version of the RRPGE
**             License): see LICENSE.GPLv3 and LICENSE.RRPGEvt in the project
**             root.
**  \date      2014.11.29
**
**  Tests the code designed for the RRPGE User Library's math component, the
**  us_rec32 function.
**
**  This code was used to design and test this RRPGE library component.
*/


#include <stdio.h>


int main(void)
{
 unsigned int a;
 unsigned int x;
 unsigned int d;
 unsigned int r;
 unsigned int p;
 unsigned int dc = 0U;


 for (a = 0x1U; a < 0xFFFFFFFFU; a++){ /* 0 and 0xFFFFFFFFU skipped, won't work there */

  r = (0x100000000ULL / a); /* True result to check algorithm */


  if (a < 0x4000U){

   /* Divide chain. On RRPGE this can be done relatively fast, less than about
   ** 50 cycles for an iteration. */

   x  = (0xFFFFU / a);
   p  = ((0x10000U - x) * a) & 0xFFFFU;
   if (p == a){ p = 0U; x++; }
   x <<= 16;
   p <<= 2;
   x += ((p / a) << 14);
   p  = ((p % a) << 2);
   x += ((p / a) << 12);
   p  = ((p % a) << 2);
   x += ((p / a) << 10);
   p  = ((p % a) << 2);
   x += ((p / a) << 8);
   p  = ((p % a) << 2);
   x += ((p / a) << 6);
   p  = ((p % a) << 2);
   x += ((p / a) << 4);
   p  = ((p % a) << 2);
   x += ((p / a) << 2);
   p  = ((p % a) << 2);
   x += (p / a);

  }else if (a >= 0x10000000U){

   if (a <= 0x80000000U){

    /* Simple approximation with division, corrected with one digit where
    ** necessary. */

    x = 0xFFFFU / ((a + 0x10000U) >> 16);
    p = (0x100000000ULL - (1ULL * x * a));
    if (a <= p){ x += 0x01U; }

   }else{

    x = 1U;

   }

  }else{

   /* Approximation branch set: the comparisons are assumed to be done on
   ** 'a >> 3' to make it fit in a 16 bit range for RRPGE. The approximators
   ** are set up so they are OK (undershoot or equal '1 / a') for all 'a'
   ** values having identical 'a >> 3'. This branch set is generated by the
   ** nrbranch.c code. */

   if (a <= 0x04137U){       /* 0x0826 */
    x = 0x3ECECU;
   }else if (a <= 0x0469FU){ /* 0x08D3 */
    x = 0x39FFEU;
   }else if (a <= 0x04C7FU){ /* 0x098F */
    x = 0x358B9U;
   }else if (a <= 0x05347U){ /* 0x0A68 */
    x = 0x312F5U;
   }else if (a <= 0x05AB7U){ /* 0x0B56 */
    x = 0x2D270U;
   }else if (a <= 0x06317U){ /* 0x0C62 */
    x = 0x29561U;
   }else if (a <= 0x06CA7U){ /* 0x0D94 */
    x = 0x25B2BU;
   }else if (a <= 0x07777U){ /* 0x0EEE */
    x = 0x22494U;
   }else if (a <= 0x083A7U){ /* 0x1074 */
    x = 0x1F1CBU;
   }else if (a <= 0x091AFU){ /* 0x1235 */
    x = 0x1C1DAU;
   }else if (a <= 0x0A1B7U){ /* 0x1436 */
    x = 0x19541U;
   }else if (a <= 0x0B3C7U){ /* 0x1678 */
    x = 0x16C8AU;
   }else if (a <= 0x0C8C7U){ /* 0x1918 */
    x = 0x14669U;
   }else if (a <= 0x0E0CFU){ /* 0x1C19 */
    x = 0x12384U;
   }else if (a <= 0x0FCC7U){ /* 0x1F98 */
    x = 0x10343U;
   }else if (a <= 0x11D37U){ /* 0x23A6 */
    x = 0x0E5C7U;
   }else if (a <= 0x1435FU){ /* 0x286B */
    x = 0x0CAAAU;
   }else if (a <= 0x17027U){ /* 0x2E04 */
    x = 0x0B203U;
   }else if (a <= 0x1A547U){ /* 0x34A8 */
    x = 0x09B90U;
   }else if (a <= 0x1E447U){ /* 0x3C88 */
    x = 0x08753U;
   }else if (a <= 0x22FFFU){ /* 0x45FF */
    x = 0x07507U;
   }else if (a <= 0x28B77U){ /* 0x516E */
    x = 0x06499U;
   }else if (a <= 0x2FACFU){ /* 0x5F59 */
    x = 0x055EAU;
   }else if (a <= 0x3838FU){ /* 0x7071 */
    x = 0x048DAU;
   }else if (a <= 0x42CF7U){ /* 0x859E */
    x = 0x03D4EU;
   }else{
    x = 0xFFFFU / ((a + 0x10000U) >> 16);
   }

   /* 2 steps of Newton-Raphson, producing a result which may be at most 0x7
   ** smaller than the true '1 / a'. The N-R step normally would look as
   ** follows:
   ** x += (1ULL * x * (0x100000000ULL - (1ULL * a * x))) >> 32;
   ** It is optimized for RRPGE to evaulate roughly as:
   ** x += (1ULL * x * (((0U - a) * x) & 0xFFFFFFFFU)) >> 32;
   ** Then in addition to this, it is shifted left by 2, so it is possible to
   ** do the approximation in 16 bits with a loss of precision (which will be
   ** fixed below with restoring division). Some further cheats are also added
   ** to make things even faster at the cost of some more precision, which is
   ** affordable given this loss can be corrected. */

   x >>= 2;
   a <<= 2;
   p  = ((0U - a) * x) & 0xFFFFFFFFU;
   x += (((p >> 16) * (x & 0xFFFFU)) >> 16);
   p  = ((0U - a) * x) & 0xFFFFFFFFU;
   x += (((p >> 16) * (x & 0xFFFFU)) >> 16);
   p  = ((0U - a) * x) & 0xFFFFFFFFU;
   x <<= 2;
   a >>= 2;

   /* Post-correct 4 bits by restoring division. The highest nybble of 'a' is
   ** zero here as those values are processed with a different algorithm. */

   a <<= 3;
   if (a <= p){ x += 0x08U; p -= a; }
   a >>= 1;
   if (a <= p){ x += 0x04U; p -= a; }
   a >>= 1;
   if (a <= p){ x += 0x02U; p -= a; }
   a >>= 1;
   if (a <= p){ x += 0x01U; }

  }


  /* Check result */

  d = r - x;
  if (d != 0U){ dc++; }
  if (d != 0U){ printf("%04X: r: %08X, x: %08X, d: %08X\n", a, r, x, d); }

  /* Output steps */

  if (a < 0x00100000U){
   if ((a & 0x00000FFFU) == 0U){
    printf("At: %08X, diffs: %u\n", a, dc);
   }
  }

  if ((a & 0x00FFFFFFU) == 0U){
   printf("At: %08X, diffs: %u\n", a, dc);
  }

 }

 printf("Finished, diffs: %u\n", dc);

 return 0;
}
